# Семинар №7 по СДА, спец. СИ - Дървета. BST, AVL, Red-Black Tree

## Дърво
Нека започнем с термина дърво. Какво значи той? От дискретната математика знаем, че дървото е свързан ацикличен граф. Нека си представим, че не знаем какво е граф - 
ще го учим по-натам в курса. Дървото е структура от данни, чиито елементи са т.нар. възелчета. Те са свързани помежду си с ребра. Сега ще разгледаме няколко имплементации 
на дърветата..

#### **Първи начин:** Чрез вектор от децата
```c++
template <class T>
struct Node
{
    T data;
    std::vector<Node*> children;
}
```

#### **Втори начин:** Чрез вектор от децата и родител
```c++
template <class T>
struct Node
{
    T data;
    Node* parent;
    std::vector<Node*> children;
}
```

#### **Трети начин:** Чрез списък на родителите

Този подход е полезен, когато върховете ни са номерирани със стойности в интервал [0, N]. Създаваме масив с N елемента, в който на всеки индекс i се намира номерът на родителя на възел с номер i. Кореновият елемент най-често се обозначава като родител сам на себе си (ако root елементът се номер 4, то parentArr[4] = 4) или на негово място се пише -1.
Какви са предимствата на този начин? Можем да имплементираме каквото искаме дърво така.

#### **Четвърти начин:** Чрез списък за пълно двоично дърво

Двоично дърво (**Binary tree**) наричаме дърво, за което всеки възел има най-много две деца (ляво и дясно). Празното дърво е двиочно. Всеки възел, чиито 2 наследника са двоични дървета, е двоично дърво.

Пълно дърво (**Complete tree**) наричаме дърво, за което всяко ниво е запълнено изцяло, с изключение на последното, което е запълнено донякъде, но задължително отляво-надясно. 

Можем да използваме следното представяне за пълно двоично дърво, чиито върхове са номерирани от 0 до N в реда на обхождане в широчина:
* Създаваме вектор, за който на индекс 0 стои коренът на дървото.
* За всеки елемент с номер i, неговите деца са записани на позиции 2i+1 (ляво дете) и 2i+2 (дясно дете). 

(Пример за това представяне ще видим на темата за двоични пирамиди)

#### **Други начини:** 
- Чрез представяния на граф
Спрямо първата дефиниця, която разгледахме, дървото е частен случай на граф. Следователно всяко от представянията за графи може да се използва, за да се зададе и структурата на дърво. Примери за това са:
* Списък на ребрата
* Списък на наследниците
* Матрица на съседство

### Двоично наредено дърво (за търсене) - BST
Двоично наредено дърво е дърво, за което стойността на всеки възел е по-голяма от всички елементи в лявото му поддърво и е по-малка от всички елементи в дясното му поддърво.

Забележете, че не е достатъчно да сръвним възелът с неговите преки ляв и десен наследник, тъй като това не ни гарантира, че надолу в поддървото няма елемент, чупещ горното правило.

Името на BST идва от хубавото му свойство, че проверката дали елемент се съдържа в него е изключително проста. Сравняваме даденият елемент с кореновият елемент. Ако е по-малък, повтаряме за лавото поддърво. Ако е по-голям - за дясното. Правим го докато не открием търсеният елемент или не установим липсата му.

В дефиницията по-горе използвахме операциите "по-голямо" и "по-малко", но в реална имплементация не е задължително да сравняваме числови стойности. Най-често се използва двуместен предикат, който, ако е в сила - елементът трябва да бъде поставен в ляво от текущия, а ако не е - в дясно от текущия.

### Операции с BST
* find:
  * Average-Case - Theta(log(n))
  * Worst-Case - Theta(n)

* insert:
  * Average-Case - Theta(log(n))
  * Worst-Case - Theta(n)

* erase:
  * Average-Case - Theta(log(n))
  * Worst-Case - Theta(n)

Важно е да забележим, че в най-лошия случай тези операции са линейни. Това се дължи на факта, че в случая говорим за обикновено BST. Едносвързан сортиран свързан списък също влиза в дефиницията на BST (така нареченото изродено BST), а търсенето в свързан списък, както знаем от предните теми, е линейно.

### Балансирано BST
**Balance Factor** - число, което оценява колко "балансиран" е всеки от върховете (дава оценка по зададен критерий). Чрез него можем да дефинираме изисквания за балансиране на дървото.

Дефинирайки **balance factor** за всеки един връх, можем да дадем оценка колко близко до желано състояние (наречено балансирано състояние) е дадено дърво. В балансирано дърво операциите са с логаритмична сложност в най-лошият случай.

Свойството "балансираност" не е задължително да бъде дефинирано чрез balance factor, но много често е удобно да се използва.

### Самобалансиращи се BST - AVL
Както името подсказва, самобалансиращите се дървета сами гарантират своята балансираност. Конкретен пример за това е AVL дървото (кръстено на своите създатели), което използва следният balance factor за оценка:

BalanceFactor(n) = Height(n->left) - Height(n->left)

(note: разглеждаме височина като брой ребра в най-дългия път от корен до кое да е листо)

Правило за балансираност: за всеки връх n, |BalanceFactor(n)| <= 1

Процесът по балансиране се случва автоматично при добавяне и премахване на елемент. В случаят на AVL дървета това се извършва чрез операциите за лява и дясна **ротация**.

[Добра визуализация на ротациите](https://www.programiz.com/dsa/avl-tree)

<img width="767" alt="image" src="https://github.com/user-attachments/assets/150b88f3-f1ff-4e42-b25b-872b37cfede5">


### Самобалансиращи се BST - Red-Black
Балансираността тук не е дефинирана чрез balance factor, а чрез редица свойства, които винаги трябва да са в сила (така наречения **инвариант**).

Инвариантът на Red-Black Tree гласи:
1) Всеки възел има цвят - черен или червен

2) Всеки NIL възел (празен възел) е черен

3) Червен възел не може да има червен наследник

4) Всеки път от произволен връх до всички NIL елементи в поддървото му трябва да преминава през равен брой черни върхове

5) Коренът винаги е черен (не е задължително, но често се прилага)

* Следствие: Ако произволен връх има точно 1 наследник, то той е червен

Балансирането отново се извършва по време на самите операции за добавяне и премахване. Отново се разчита на принципа на ротациите, но също така има случаи в които вместо ротация се предпочита обикновенно преоцветяване на върховете.

### Дървета в STL
В STL разполагаме със следните колекции, които работят именно чрез Red-Black дървета:

* `std::set<T>` - множество от елементи без повторение
* `std::multiset<T>` - множество от елементи с повторение
* `std::map<K,V>` - множество от двойки ключ-стойност
* `std::multi-map<K,V>` - множество от двойки ключ-стойност

## Задачи 🌻
[Max Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree)

[Min Depth of Binary Tree](https://leetcode.com/problems/minimum-depth-of-binary-tree)

[Validate BST](https://leetcode.com/problems/validate-binary-search-tree/)

[Symmetric Tree](https://leetcode.com/problems/symmetric-tree)

[Царство](https://www.hackerrank.com/contests/kontrolno-3/challenges/challenge-4346)

[Час по рисуване](https://www.hackerrank.com/contests/sda-hw-6-2023/challenges/task3score/problem)

[Longest Substring Without Repeating Elements](https://leetcode.com/problems/longest-substring-without-repeating-characters)

[Волейболни другарчета](https://www.hackerrank.com/contests/sda-hw-8/challenges/volleyball-friends)
