# Семинар №9 по СДА - Динамично програмиране

## Какво е Dynamic Programming (DP)
DP e техника/парадигма за решаване на задачи, която преобразува един “голям” проблем в много по-малки подпроблеми, решава ги поотделно и комбинира решенията, за да получи окончателния отговор.

Основната идея е — когато при “груба” рекурсия се повтарят много подпроблеми, това може да доведе до излишни изчисления. DP ни позволява да запомним (memoize/tabulate) решенията на подпроблеми и да ги използваме повторно. 

## Кога е подходящо да използваме DP
Преди да пристъпим към DP, трябва да проверим дали задачата притежава две ключови свойства:
- `Overlapping subproblems` — задачата може да се раздели на подпроблеми, които се припокриват (т.е. едни и същи подпроблеми се решават многократно при рекурсия).

Какво значи това?

При рекурсивното brute-force решение изчисляваме едни и същи подпроблеми многократно.

Да го видим на пример: fib(6)

Рекурсивното дърво изглежда така:

```
                        fib(6)
                   /             \
             fib(5)              fib(4)
           /       \            /       \
      fib(4)     fib(3)    fib(3)      fib(2)
      /   \      /   \      /   \
 fib(3) fib(2) fib(2) fib(1) fib(2) fib(1)
 ```


Какво виждаме?
- fib(4) се пресмята 2 пъти
- fib(3) се пресмята 3 пъти
- fib(2) се пресмята 5 пъти
и така нататък…

С увеличаване на n, броят на повторните изчисления расте експоненциално. Следователно можем да запомним резултата за fib(k) и след това да го използваме навсякъде, вместо да го смятаме пак.


- `Optimal substructure` — оптималното решение на цялата задача може да бъде получено чрез оптимални решения на подпроблемите.

За да получим най-правилната стойност за F(n), трябва да знаем правилните стойности на F(n−1) и F(n−2) и просто ги комбинираме чрез рекурентната формула.
Това е оптимална подструктура, защото:

- Решението на голям проблем (F(n)) зависи от решенията на по-малки подпроблеми (F(n−1) и F(n−2)).
- Тези подпроблеми са независими и трябва да бъдат оптимални, за да може комбинираният резултат да е оптимален/правилен.
- Не се налага да търсим алтернативни комбинации — формулата определя единствен правилен начин за комбиниране.

##  Как обикновено стигаме до решение с DP?
- Първо намираме как би изглеждало базовото рекурсивно решение. Това показва рекурентата връзка на подпроблемите. 
- Добавяме структура (масив/речник/таблица), в която да “запомняме” вече изчислени подпроблеми, за да избегнем повторно пресмятане. 
- Вместо рекурсия, можем да пробваме да обходим пространството на подпроблемите итеративно, попълвайки таблица (или масив) с решенията. Това премахва ограничението на call stack и често е по-ефективно/по-стабилно.

## Кои са подходите при DP?
### Мемоизация = Рекурсия + Запомняне на резултатите

Memoization (мемоизация) е техника, при която:
- Пишем функция рекурсивнo;
- Когато функцията се извика:
  - Първо проверяваме дали вече сме изчислили резултата
    - Ако да → връщаме запомненото  
    - Ако не → смятаме, запазваме в cache, връщаме
   
### Табулация = Итеративно решение с таблица (масив), попълвана отдолу нагоре
Когато използваме табуация:
- Избираме структура (обикновено масив/таблица dp)
- Попълваме dp[0], dp[1], … базови случаи
- Итеративно изграждаме dp[i] от dp[j], където j < i
- dp[n] е решението.

---
## Задачи⭐
- [**Fibonacci Number**](https://leetcode.com/problems/fibonacci-number/)
- [**Coin Change**](https://leetcode.com/problems/coin-change/description/)
- [**House Robber**](https://letcode.com/problems/house-robber)
- [**Unique Paths**](https://leetcode.com/problems/unique-paths/)
- [**Максимален път в матрица**](https://www.hackerrank.com/contests/sda-2022-2023-test7-123-43/challenges/1-454/)
- [**Longest Common Subsequence**](https://leetcode.com/problems/longest-common-subsequence/)
- [**Longest Increasing Subsequence**](https://leetcode.com/problems/longest-increasing-subsequence/)
